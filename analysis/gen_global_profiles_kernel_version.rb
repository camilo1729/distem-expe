# There is a directory per number of machines, then there is a directory per type 
# of experiment i.e. distem,real.
# After, we have a directory for each kernel version and then different directories that 
# contains the profiles for a paraticular run. 
# These directories are tagged with the number of nodes and a timestamp. 




puts "Generating global profiles"

nodes_dirs = Dir.glob("nodes_*")

kernel_versions = ["3.2","3.16","4.0"]


PATH_PPROF = `cd ..; find \`pwd\` -name pprof`.chop
# iterating over the number of machines
nodes_dirs.each do |num|

  # iterating over the type of experiment
  ["distem","real"].each do |type|
    # iterating over the kernel version
    kernel_versions.each do |version|
      all_profiles = Dir.glob("#{num}/#{type}/kernel#{version}/profile-*")
      num_nodes = all_profiles.map{ |line| /profile-(\d+)/.match(line)[1] }.uniq
      # iterating over the number of nodes, this only applies to distem because different number of vnodes were tested
      num_nodes.each do |num_v|
        
        profile_dirs = Dir.glob("#{num}/#{type}/kernel#{version}/profile-#{num_v}-*")
        output = ""
        profile_dirs.each{ |p_dir|
          puts "Generating global profile for directory #{p_dir}"
          # We enter the profile directory and get a summary of the profile generated by each MPI process
          # This summary is done using pprof provided by TAU. The values in the summary are the mean between all MPI process.
          res= `cd #{p_dir} && #{PATH_PPROF} -s | grep mean -A100` 
          # We clean up the output to have a proper column format that can be read using R.
          res.sub! "int main(int, char **)", "int_main"
          res.sub! "EXACT [THROTTLED]","EXACT"
          res.each_line{ |line| output+= line if (/^\d/.match(line.strip) and not line[".TAU"]) }
        }
        
        # We merge the summary of each run into a file.
        File.open("profile_global_#{num}_#{type}_#{version}_#{num_v}.txt",'w+') do |f|
          f.puts output
        end
        
      end
    end
  end
end



